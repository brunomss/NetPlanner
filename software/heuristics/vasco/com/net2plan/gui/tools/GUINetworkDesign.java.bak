/*******************************************************************************
 * Copyright (c) 2013-2015 Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v3
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 *
 * Contributors:
 *     Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza - initial API and implementation
 ******************************************************************************/
package com.net2plan.gui.tools;

import com.net2plan.gui.utils.ParameterValueDescriptionPanel;
import com.net2plan.gui.utils.ThreadExecutionController;
import com.net2plan.internal.ErrorHandling;
import com.net2plan.gui.utils.RunnableSelector;
import com.net2plan.interfaces.networkDesign.*;
import com.net2plan.internal.SystemUtils;
import com.net2plan.utils.ClassLoaderUtils;
import com.net2plan.utils.Triple;
import java.awt.Color;
import java.awt.event.*;
import java.io.Closeable;
import java.io.File;
import java.util.*;
import javax.swing.*;
import javax.swing.border.LineBorder;
import net.miginfocom.swing.MigLayout;

/**
 * Targeted to evaluate the network designs generated by built-in or user-defined
 * static planning algorithms, deciding on aspects such as the network topology,
 * the traffic routing, link capacities, protection routes and so on. Algorithms
 * based on constrained optimization formulations (i.e. ILPs) can be fast-prototyped
 * using the open-source Java Optimization Modeler library, to interface
 * to a number of external solvers such as GPLK, CPLEX or IPOPT.
 *
 * @author Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza
 * @since 0.2.0
 */
public class GUINetworkDesign extends IGUINetworkViewer
{
	private final static String title = "Offline network design";
	
	private JPanel executionPane;
	private JTextArea txt_netPlanLog;
	private ThreadExecutionController algorithmController;
	private RunnableSelector algorithmSelector;
	private long start;

	/**
	 * Default constructor.
	 * 
	 * @since 0.2.0
	 */
	public GUINetworkDesign()
	{
		this(title);
	}
	
	/**
	 * Constructor that allows set a title for the tool in the top section of the panel.
	 * 
	 * @param title Title of the tool (null or empty means no title)
	 * @since 0.2.0
	 */
	public GUINetworkDesign(String title)
	{
		super(title);
	}
	
	@Override
	protected boolean allowLoadTrafficDemands()
	{
		return true;
	}
	
	@Override
	public void configure(JPanel contentPane)
	{
		super.configure(contentPane);
		
		File ALGORITHMS_DIRECTORY = new File(CURRENT_DIR + SystemUtils.getDirectorySeparator() + "workspace");
		ALGORITHMS_DIRECTORY = ALGORITHMS_DIRECTORY.isDirectory() ? ALGORITHMS_DIRECTORY : CURRENT_DIR;

		ParameterValueDescriptionPanel algorithmParameters = new ParameterValueDescriptionPanel();
		algorithmSelector = new RunnableSelector("Algorithm", null, IAlgorithm.class, ALGORITHMS_DIRECTORY, algorithmParameters);
		algorithmController = new ThreadExecutionController(this);
		JPanel pnl_buttons = new JPanel(new MigLayout("", "[center, grow]", "[]"));

		JButton btn_solve = new JButton("Execute");
		pnl_buttons.add(btn_solve);
		btn_solve.addActionListener(new ActionListener()
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				algorithmController.execute();
			}
		});
		
		addKeyCombinationAction("Execute algorithm", new AbstractAction()
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				showTab(1);
				algorithmController.execute();
			}
		}, KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));

		executionPane = new JPanel();
		executionPane.setLayout(new MigLayout("insets 0 0 0 0", "[grow]", "[grow]"));
		executionPane.add(algorithmSelector, "grow");
		executionPane.add(pnl_buttons, "dock south");
		
		addTab("Algorithm execution", executionPane, 1);
	}

	@Override
	protected JPanel configureLeftBottomPanel()
	{
		txt_netPlanLog = new JTextArea();
		txt_netPlanLog.setFont(new JLabel().getFont());
		JPanel pane = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
		pane.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Warnings"));
		pane.add(new JScrollPane(txt_netPlanLog), "grow");
		return pane;
	}

	@Override
	public Object execute(ThreadExecutionController controller)
	{
		if (controller == algorithmController)
		{
			start = System.nanoTime();
			final Triple<File, String, Class> algorithm = algorithmSelector.getRunnable();
			final Map<String, String> algorithmParameters = algorithmSelector.getRunnableParameters();
			final Map<String, String> net2planParameters = Configuration.getNet2PlanOptions();
			NetPlan netPlan = getDesign().copy();
			IAlgorithm instance = ClassLoaderUtils.getInstance(algorithm.getFirst(), algorithm.getSecond(), IAlgorithm.class);
			String out = instance.executeAlgorithm(netPlan, algorithmParameters, net2planParameters);
			try { ((Closeable) instance.getClass().getClassLoader()).close(); }
			catch (Throwable e) { }
			netPlan.setNetworkLayerDefault(netPlan.getNetworkLayer ((int) 0));
			getDesign().assignFrom(netPlan);
			return out;
		}
		else
		{
			return super.execute(controller);
		}
	}

	@Override
	public void executionFailed(ThreadExecutionController controller)
	{
		if (controller == algorithmController)
		{
			ErrorHandling.showErrorDialog("Error executing algorithm");
		}
		else
		{
			super.executionFailed(controller);
		}
	}

	@Override
	public void executionFinished(ThreadExecutionController controller, Object out)
	{
		if (controller == algorithmController)
		{
			try
			{
				double execTime = (System.nanoTime() - start) / 1e9;
				topologyPanel.updateLayerChooser();
				getTopologyPanel().getCanvas().zoomAll();

				String outMessage = String.format("Algorithm executed successfully%nExecution time: %.3g s%nExit message: %s", execTime, out);
				JOptionPane.showMessageDialog(null, outMessage, "Solve design", JOptionPane.PLAIN_MESSAGE);
				showNetPlanView();
			}
			catch (Throwable ex)
			{
				ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
				ErrorHandling.showErrorDialog("Error executing algorithm");
			}
		}
		else
		{
			super.executionFinished(controller, out);
		}
	}

	@Override
	public String getDescription()
	{
		return getName();
	}
	
	@Override
	public KeyStroke getKeyStroke()
	{
		return KeyStroke.getKeyStroke(KeyEvent.VK_1, InputEvent.ALT_DOWN_MASK);
	}

	@Override
	public String getMenu()
	{
		return "Tools|" + title;
	}

	@Override
	public String getName()
	{
		return title + " (GUI)";
	}

	@Override
	public List<Triple<String, String, String>> getParameters()
	{
		return null;
	}
	
	@Override
	public boolean isEditable()
	{
		return true;
	}
	
	@Override
	protected void reset_internal()
	{
		super.reset_internal();
		algorithmSelector.reset();
	}

	@Override
	protected void updateLog(String text)
	{
		txt_netPlanLog.setText(null);
		txt_netPlanLog.setText(text);
		txt_netPlanLog.setCaretPosition(0);
	}
}